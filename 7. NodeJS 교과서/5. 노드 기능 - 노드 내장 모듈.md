# 노드 내장 모듈

## os

- 운영체제의 정보를 가져올 수 있다.
- 필요할 때 찾아서 사용

- os.arch(): process.arch와 동일합니다.
- os.platform(): process.platform과 동일합니다.
- os.type(): 운영체제의 종류를 보여줍니다.
- os.uptime(): 운영체제 부팅 이후 흐른 시간(초)을 보여줍니다.
    (process.uptime()은 노드의 실행 시간이었습니다.)
- os.hostname(): 컴퓨터의 이름을 보여줍니다.
- os.release(): 운영체제의 버전을 보여줍니다.
- os.homedir(): 홈 디렉터리 경로를 보여줍니다.
- os.tmpdir(): 임시 파일 저장 경로를 보여줍니다.
- os.cpus(): 컴퓨터의 코어 정보를 보여줍니다.
- os.freemem(): 사용 가능한 메모리(RAM)를 보여줍니다.
- os.totalmem(): 전체 메모리 용량

## path

- 폴더와 파일의 경로를 쉽게 조작하도록 도와주는 모듈이다.

```javascript / path.js
const path = require('path');

const string = __filename;

console.log('path.sep:', path.sep); // 경로 구분자
console.log('path.delimiter:', path.delimiter); // 환경변수 구분자
console.log('------------------------------');
console.log('path.dirname():', path.dirname(string)); // 파일의 경로
console.log('path.extname():', path.extname(string)); // 파일의 확장자
console.log('path.basename():', path.basename(string)); // 파일의 이름(확장자 포함)
console.log('path.basename - extname:', path.basename(string, path.extname(string)));
console.log('------------------------------');
console.log('path.parse()', path.parse(string));
console.log('path.format():', path.format({
  dir: 'C:\\users\\zerocho',
  name: 'path',
  ext: '.js',
}));
console.log('path.normalize():', path.normalize('C://users\\\\zerocho\\\path.js'));
console.log('------------------------------');
console.log('path.isAbsolute(C:\\):', path.isAbsolute('C:\\'));
console.log('path.isAbsolute(./home):', path.isAbsolute('./home'));
console.log('------------------------------');
console.log('path.relative():', path.relative('C:\\users\\zerocho\\path.js', 'C:\\'));
console.log('path.join():', path.join(__dirname, '..', '..', '/users', '.', '/zerocho'));
console.log('path.resolve():', path.resolve(__dirname, '..', 'users', '.', '/zerocho'));
```

## url

- 인터넷 주소 조작 모듈

```javascript

const url = require('url'); 
const { URL } = url; // URL은 노드 내장 객체라서 require할 필요는 없다.

const myURL = new URL('http://www.gilbut.co.kr/book/bookList.aspx?sercate1=001001000#anchor');
console.log('new URL():', myURL);
console.log('url.format():', url.format(myURL));
```

- url 주소값을 인수로 받아서 url를 분해해서 여러가지 유용한 값으로 리턴한다.

## searchParams

``` javascript searchParams.js

const myURL = new URL('http://www.gilbut.co.kr/?page=3&limit=10&category=nodejs&category=javascript');
console.log('searchParams:', myURL.searchParams);
console.log('searchParams.getAll():', myURL.searchParams.getAll('category'));
console.log('searchParams.get():', myURL.searchParams.get('limit'));
console.log('searchParams.has():', myURL.searchParams.has('page'));

console.log('searchParams.keys():', myURL.searchParams.keys());
console.log('searchParams.values():', myURL.searchParams.values());

myURL.searchParams.append('filter', 'es3');
);
myURL.searchParams.append('filter', 'es5');
console.log(myURL.searchParams.getAll('filter'));

myURL.searchParams.set('filter', 'es6');
console.log(myURL.searchParams.getAll('filter'));

myURL.searchParams.delete('filter');
console.log(myURL.searchParams.getAll('filter'));

console.log('searchParams.toString():', myURL.searchParams.toString());
myURL.search = myURL.searchParams.toString();

```

- URLSearchParams는 URL과 마찬가지로 노드 내장 객체이다. 별도로 임포트할 필요가 없다.

## dns

- dns를 다룰 때 사용하는 모듈
- 도메인을 통해 ip나 dns 정보를 얻고자 할 때 사용함

``` javascript dns.mjs

import dns from 'dns/promises';

const ip = await dns.lookup('gilbut.co.kr');
console.log('IP', ip);

const a = await dns.resolve('gilbut.co.kr', 'A');
console.log('A', a);

const mx = await dns.resolve('gilbut.co.kr', 'MX');
console.log('MX', mx);

const cname = await dns.resolve('www.gilbut.co.kr', 'CNAME');
console.log('CNAME', cname);

const any = await dns.resolve('gilbut.co.kr', 'ANY');
console.log('ANY', any);

```

## crypto

- 암호화 모듈

### 단방향 모듈

- 복호화할 수 없는 암호화
- 주로 해시 함수를 사용한다.

``` javascript hash.js
const cryto = require('cryto');

console.log('base64:', cryto.createHash('sha512').update('password1').digest('base64'));
console.log('hex:', cryto.createHash('sha512').update('password2').digest('hex'));
console.log('base64:', cryto.createHash('sha512').update('password3').digest('base64'));
```

- createHash(해시 알고리즘) 
- update(문자열) : 인수로 암호화할 비밀번호을 입력한다.
- digest(인코딩) : 인코딩할 알고리즘

- 현재 주로 비밀번호를 암호화하는 알고리즘 중 노드가 지원하는 알고리즘은 pbkdf2 이다.


``` javascript pbkdf2.js

const crypto = require('crypto');

crypto.randomBytes(64,(err,buf)=>{
    const salt = buf.toString('base>64');
    console.log('salt:',salt);
    crypto.pbkdf2('password',salt,100000,64,'sha>512',(err,key)=>{
        console.log('password:' key.toString('base>64'));
    });
});

```

- 먼저 randomBytes() 메서드로 64바이트 문자열을 생성한다. 이것이 salt
- pbkdf2 메서드에 비밀번호, 솔트, 반복횟수, 출력바이트, 해시알고리즘을 인수로 넣는다.
- 예시 코드에서는 10만번을 반복한다.
- pbkdf2 메서드는 내부적으로 멀티 스레딩으로 동작하여 10만번을 반복해도 1초 정도 걸린다.
- pbkdf2는 간단하지만 bcrypto 방식에 비해 취약하므로 앞으로 bcrypto 사용한다.

### 양방향 암호화 모듈