

## new 연산자

## 콜백함수

## 배열과 배열 고차함수

## 표현식(expression)인 문(statement)과 표현식이 아닌 문
- 값 : 식(표현식)이 평가되어 생성된 결과
- 변수 : 하나의 값을 저장하기 위해 확보한 메모리 공간 또는 그 메모리 공간에 붙인 이름
- 리터럴 : 사람이 이해할 수 있는 문자나 기호를 사용해 값을 생성하는 표기법
- 표현식 : 값으로 평가될 수 있는 문
- 문(statement) : 프로그램을 구성하는 기본단위이자 최소 실행 단위. 문은 토큰으로 구성된다. 토큰은 문법적인 의미를 가지면서 더이상 나눌 수 없는 코드의 구성요소이다.
예> 선언문, 할당문, 조건문, 반복문
- 문에는 표현식인 문과 표현식이 아닌 문이 있다. 표현식이 아닌 문은 값으로 평가될 수 없는 문이다.

## 스코프
- 스코프(유효범위)
    - 모든 식별자(변수, 객체, 함수 등)는 자신이 선언된 위치에 의해 다른 코드가 자신을 참조할 수 있는 유효범위가 결정된다.
    - 즉 스코프란 식별자가 유효한 범위이다.
    - 지역 스코프 : 함수 몸체 내부
    - 전역 스코프
    - 변수를 참조할 때 자바스크립트 엔진은 스코프 체인을 통해 변수를 참조하는 코드의 소코프에서 시작하여 상위 스코프 방향으로 이동하며 선언된 변수를 검색한다.
    - 함수 레벨 스코프
        - var 변수선언 키워드로 선언된 변수는 오직 함수의 코드블록만을 지역스코프로 인정하는데 이를 함수레벨 스코프라고 한다.
    
    ### 렉시컬 스코프(정적 스코프)
    ```javascript
    var x= 1;
    function foo(){
        var x = 10;
        bar();
    }
    function bar(){
        console.log(x);
    }
    foo(); // 10
    bar();  // ?
    ```
    - 여기서 bar()가 출력하는 결과가 1이라면 bar() 상위 스코프는 전역 스코프라는 의미이고 어떠한 함수의 상위스코프가 호출위치에 의해 결정된다는 의미이다. 이를 동적 스코프라고 한다.
    - 반대로 bar()가 출력하는 결과가 10이라면 상위스코프는 foo()의 지역스코프라는 의미르고 다시 함수의 상위스코프가 호출위치가 아닌 정의 위치에 의해 결정된다는 의미이다. 이를 정적 스코프 또는 렉시컬 스코프라고 한다. 자바스크립트를 비롯한 대부분의 프로그램 언어에서 렉시컬 스코프를 따른다.


## 비동기 프로그래밍

- 자바스크립트 엔진은 단 하나의 실행 컨텍스트를 가진다.
- 이는 함수의 실행 창구가 하나이며 2개 이상의 함수가 동시에 실행할 수 없다는 것이다.
- 자바스크립트 엔진은 싱글 스레드 방식으로 동작한다.
- 그러므로 처리에 시간이 걸리는 테스크를 실행하면 블로킹(작업중단)이 발생한다.
- 비동기 함수를 실행하면 실행 중인 태스크가 종료되지 않더라도 다음 테스크를 곧바로 실행한다. 
- 이러한 처리 방식을 비동기 처리라고 한다.
- 비동기 처리를 수행하는 비동기 함수는 전통적으로 콜백 패턴을 사용한다.


## 이벤트 루프와 태스크 큐
- 자바스크립트 엔진은 싱글스레드 방식으로 동작함에도 브라우저는 많은 태스크를 동시에 처리하는 것처럼 보인다.
- 자바스크립트의 동시성을 지원하는 것이 바로 이벤트 루프이다.
- 이벤트 루프는 브라우저에 내장되어 있다.
- 이벤트 루프는 자바스크립트 엔진 내 콜스택에 현재 실행 중인 컨텍스트가 있는지와 브라우저 내 태스크 큐에 대기 중인 함수가 있는지를 반복적으로 확인한다.
- 만약 콜스택이 비어있고 태스크 큐에 대기 중인 함수가 있다면 FIFO 방식으로 태스크 큐에서 콜스택으로 함수를 이동시킨다.
- 태스크큐 - 비동기 함수의 콜백함수 또는 이벤트핸들러가 일시적으로 보관되는 영역이다. 테스크큐와 별도로 프로미스 처리 메서드의 콜백함수는 마이크로태스크큐에 보관된다.
- 이와 같이 자바스크립트는 싱글스레드로 동작하지만 브라우저는 멀티 스레드로 동작하므로 전체적으로 멀티 스레드로 동작하여 비동기 처리가 가능한 것이다.

## Ajax
- 일종의 프로그래밍 방식이다.
- 자바스크립트를 사용하여 서버에 비동기적으로 데이터를 요청하고 서버가 응답한 데이터를 수신하여 웹페이지에 동적으로 갱신하는 프로그래밍 방식이다.
- 에이젝스는 브라우저에 내장된 web api인 XMLHttpRequest 객체를 기반으로 동작한다.

## JSON
- 클라이언트-서버간 http통신을 위한 텍스트 데이터 포맷이다.
- json의 키값은 반드시 더블쿼트로 묶어야 한다.
- JSON.stringify() - 객체를 데이터 전송을 위해 문자열화(직렬화)하는 메서드
- JSON.parse()

## XMLHttpRequest & Rest API - 차후 필요할 때 공부!! - 43,44장
- XMLHttpRequest
- 브라우저는 주소창이나 HTML form 또는 a 요소를 통해 http 요청 전송 기능을 기본적으로 제공한다.
- 자바스크립트를 사용하여 http 요청 전송하려면 XMLHttpRequest 객체를 사용한다.
- XMLHttpRequest 는 응답 요청과 응답 수신을 위한 메서드를 제공한다.

```javascript
const xhr = new XMLHttpRequest();

xhr.open('GET','/users');

xhr.setRequestHeader('content-type','application/json');

xhr.send();
```

- 요청 메서드
    - GET - 리소스 취득
    - POST - 리소스 생성
    - PUT - 리소스 전부 교체
    - PATCH - 리소스 일부 교체
    - DELETE - 리소스 삭제

### http 응답 처리
- 서버가 전송한 응답을 처리하려면 XMLHttpRequest 객체가 발생시키는 이벤트를 캐치해야 한다.
- 이벤트 핸들러(onreadystatechange, onload, onerror)를 사용한다.

## REST API
- REST는 http 장점을 활용하기 위해 제안된 아키텍처이다.
- REST API 설계 원칙
    - URI는 자원을 표현하는데 집중하고 행위는 http 요청 메서드(get, put, post, delete, patch)를 통한다.

## 프로미스
- 전통적인 비동기 처리 패턴인 콜백 패턴의 단점을 보완하고자 도입됨

### 전통적 비동기 처리의 단점 - 콜백 헬

- 비동기 함수는 비동기 처리결과를 외부에 반환할 수 없고, 상위스코프의 변수에 할당할 수도 없다.
    - 비동기 함수는 콜백함수를 태스크 큐에 푸시하고 undefined를 반환하고 소멸한다.
    - 태스크 큐에 푸시된 콜백함수는 콜스택에 푸시된 모든 함수를 실행하여 빈 상태에 되고 나서야 콜스택에 푸쉬되고 실행되므로 구조상 그 결과를 외부로 반환하거나 상위 스코프의 변수에 할당할 수 없다.
- 따라서 비동기 함수의 처리결과에 대한 후속처리는 비동기 함수 내부에서 수행해야 한다.
- 이 때 비동기 함수를 범용적으로 사용하기 위해 비동기 함수에 비동기 처리결과에 대한 후속 처리를 수행하는 콜백함수를 전달하는 것이 일반적이다.
- 필요에 따라 성공 콜백 함수와 실패 콜백함수를 전달할 수 있다.
```javascript

const get = (url, callbackFn)={
    const xhr = new XMLHttpRequest();
    xhr.open('GET',url);
    xhr.send();
    xhr.onload = ()=>[
        if(xhr.status===200){
            callbackFn(JSON.parse(xhr,response));            
        } else {
            console.error(`${xhr.status} ${xhr.statusText}`);
        }
    ]

    const url = "http://www.google.com/";
    get(url,(userId)=>{
        console.log(userId);
        get(`${url}/${userId}`,userInfo=>{
            console.log(userInfo);
        });
    });
}
```
- 이와 같은 콜백함수의 중첩구조는 가독성이 나쁘고 실수를 유발하므로 바람직하지 않다.
- 또한 콜백 패턴은 try catch를 통한 에러 캐치가 불가하여 새로운 패턴으로 promise가 제시되었다.

### 프로미스 생성
- 프로미스는 표준 빌트인 객체다.
- 프로미스 생성자 함수는 비동기 처리를 수행할 콜백함수를 인수로 받는데 이 콜백함수는 다시 resolve, reject 함수를 인수로 받는다.

```javascript
const promise = new Promise((resolve, reject)=>{
    if(xhr.status===200){
        resolve(xhr);
    }else{
        reject(xhr.statusText);
    }
});

```
- 실행함수(executor) (resolve, reject)
    - 실행함수는 프로미스 생성에 의해 리졸브와 리젝트 함수를 받아 즉시 실행된다.
    - 리졸브나 리젝트 함수는 프로미스를 이행하거나 거부한다.
    - Promise.resolve(value) 메서드는 promise 객체의 상태를 fulfiled로 바꾸고 인수값을 반환한다.
    - Promise.reject(reason) 메서드는 어떠한 이유로 거절된 promise 객체를 반환한다.

