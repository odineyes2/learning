## Call Signatures

```Typescript - 함수형

type Add = (a:number, b:number) => number; // call signature - 함수의 인자와 반환값의 타입을 알려준다.
const add: Add = (a,b)=>a+b;

```

- 콜 시그니처를 사용하면 함수의 타입과 로직을 분리하여 작성할 수 있다.
- 콜 시그니터를 작성하는 방법에는 두가지가 있다.(함수형, 객체형) - 콜 시그니처가 2가지 이상인 경우 객체형을 써야 한다.

```Typescript - 객체형

type Add = {
    (a:number, b:number) : number
}
const add: Add = (a,b)=>a+b;

```

## Overloading

- 같은 함수, 메소드가 인자 타입이 달라지면 로직이 달라지도록 작성한 함수이다.
- 오버로딩은 서로 다른 여러개의 콜 시그니처가 존재할 때 발생한다.
- 오버로딩이 되도록 작성할 일보다는 외부에서 제공되는 라이브러리나 프레임워크가 이런 오버로딩이 적용되어 있는 경우가 많다.

```Typescript

type Add = {
    (a:number, b:number) : number 
    (a:number, b:string) : number
}
const add: Add = (a,b)=>{
    if(typeof b === "string") return a;
    return a+b;
}

```

## polymophism & Genric

```Typescript - concrete type

type SuperPrint = {
    (arr: number[]) : void
    (arr: boolean[]) : void
    (arr: string[]) : void
}

const superPrint : SuperPrint = function (arr){
    arr.forEach((i)=>console.log(i));
}

superPrint([1,2,3])
superPrint([true, false, true])
superPrint(["1","2","3"])
superPrint([1,"2",true]) // error


```

```Typescript - generic type

type SuperPrint = {
    <T>(arr: T[]) : void    
}

const superPrint : SuperPrint = function (arr){
    arr.forEach((i)=>console.log(i));
}

superPrint([1,2,3])
superPrint([true, false, true])
superPrint(["1","2","3"])
superPrint([1,"2",true])

```

- 제네릭은 콜 시그니처(의 인자와 리턴값)에 어떤 타입이 들어올 지 모를 때 사용한다.
- 제네릭은 콜 시그니처의 타입을 비워두고 실제 함수에 들어온 파라미터의 타입을 보고 적절한 인자의 타입을 추론한다.(매우 편리)

```Typescript - generic type - 2개의 제네릭을 사용하는 경우

type SuperPrint = {
    <T,V>(arr: T[], b:V) => T
}

const superPrint : SuperPrint = (arr, b) => arr[0]

const a = superPrint([1,2,3], 4)
const b = superPrint([true, false, true], "")
const c = superPrint(["1","2","3"], "")
const d = superPrint([1,"2",true], "")

```
